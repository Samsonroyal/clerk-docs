---
title: Manual JWT verfication
description: Learn how to manually verify Clerk-generated session tokens (JWTs).
---

# Manual JWT verification

Your Clerk-generated [session tokens](/docs/backend-requests/resources/session-tokens) are essentially JWTs which are signed using your instance's private key and can be verified using your instance's public key. Depending on your architecture, these tokens will be in your backend requests either via a cookie named `__session` or via the Authorization header.

For every request, you must validate its token to make sure it hasn't expired and it is authentic (i.e. no malicious user tried to tamper with it). If these validations pass, then it means that the user is authenticated to your application and you should consider them signed in.

<Steps>

### Retrieve the session token

Retrieve the session token from either `__session` cookie for a same origin request or from the Authorization header for cross origin requests.

### Get your JWT Public Key

There are three ways to obtain your JWT Public Key:

1. Use the Backend API in JSON Web Key Set (JWKS) format at the following endpoint [https://api.clerk.com/v1/jwks](https://clerk.com/docs/reference/backend-api/tag/JWKS#operation/GetJWKS).

2. Use the Frontend API in JSON Web Key Set (JWKS) format at the following endpoint `https://<YOUR_FRONTEND_API>/.well-known/jwks.json`. This can be obtained from the Clerk Dashboard on the [API Keys](https://dashboard.clerk.com/last-active?path=api-keys) page. Select **Show JWT public key**. In the modal that appears, copy the **JWKS URL**.

3. **This option should only be used as a fallback for when the first two options are not available.** Use the PEM public key provided in the Clerk Dashboard on the [API Keys](https://dashboard.clerk.com/last-active?path=api-keys) page. Select **Show JWT public key**. In the modal that appears, copy the **PEM Public Key**.

### Verify the token signature

To verify the token signature, you should:

1. Use your JWT Public Key to verify the token's signature.
2. Validate that the token is not expired by checking the `exp` ([Expiration time](https://datatracker.ietf.org/doc/html/rfc7519#section-4.1.4)) and `nbf` ([Not before](https://datatracker.ietf.org/doc/html/rfc7519#section-4.1.5)) claims.
3. The `azp` claim in the Clerk Session JWT stands for authorized parties. If the `azp` claim exists, validate that it equals any of your known origins that are permitted to generate those tokens. This is an extra security check that we highly recommend that you do. Verifying the `azp` claim on the server side ensures that the session token is generated from the expected frontend application. For example, if you are permitting tokens retrieved from `http://localhost:3000`, then the `azp` claim should equal `http://localhost:3000`. You can also pass an array of strings like so: `['http://localhost:4003', 'https://clerk.dev']`. If the `azp` claim does not exist, then you can skip this step.

If the above process is successful, it means that the user is signed in to your application and you can consider them authenticated. You can also retrieve the session ID and user ID out of the token's claims.

</Steps>

## Example usage

The following example demonstrates how to use the [JavaScript Backend SDK](/docs/references/backend/overview) to verify the token signature. Although this example uses Next.js Route Handlers, you can use `verifyToken` with any JS framework or no framework at all.

In the following example:

1. The JWT Public Key is set in the environment variable `CLERK_JWT_KEY`.
1. The session token is retrieved from the `__session` cookie or the `Authorization` header.
1. The token is verified using the `verifyToken` function.
1. The token's `exp` and `nbf` claims are checked.
1. The token's `azp` claim is checked against the permitted origins.

<Tabs items={["Next.js"]}>
  <Tab>
  ```tsx filename="app/api/route.ts"
  import { verifyToken } from '@clerk/backend';
  import { cookies } from 'next/headers';

  export async function GET(request: Request) {
    const cookieStore = cookies()
    const sessToken = cookieStore.get('__session')?.value
    const bearerToken = request.headers.get('Authorization')?.replace('Bearer ', '');
    const token = sessToken || bearerToken;

    if (!token) {
      return Response.json({ error: 'Token not found. User must sign in.' }, { status: 401 });
    }

    try {
      const verifiedSession = await verifyToken(token, {
        jwtKey: process.env.CLERK_JWT_KEY,
      });

      // Check if the token is expired or not yet valid
      const currentTime = Math.floor(Date.now() / 1000);
      if (verifiedSession.exp < currentTime || verifiedSession.nbf > currentTime) {
        throw new Error("Token is expired or not yet valid");
      }

      // Check if the token is issued by a permitted origin
      const permittedOrigins = ["http://localhost:3000", "https://example.com"]; // Replace with your permitted origins
      if (verifiedSession.azp && !permittedOrigins.includes(verifiedSession.azp)) {
        throw new Error("Invalid 'azp' claim");
      }

      return Response.json({ verifiedSession });
    } catch (error) {
      return Response.json({ error: 'Token not verified.' }, { status: 401 });
    }
  }
  ```
  </Tab>
</Tabs>

If the token is valid, the response will return a JSON object that looks something like this:

```json
{
  "verifiedSession": {
    "azp": "http://localhost:3000",
    "exp": 1687906422,
    "iat": 1687906362,
    "iss": "https://magical-marmoset-51.clerk.accounts.dev",
    "nbf": 1687906352,
    "sid": "sess_2Ro7e2IxrffdqBboq8KfB6eGbIy",
    "sub": "user_2RfWKJREkjKbHZy0Wqa5qrHeAnb"
  }
}
```
